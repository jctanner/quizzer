{"section": "Exercise 4.16.5: Lexicographically ordering n-tuples of varying lengths.", "qid": 2, "instructions": "<div class=\"setup\">\n <p>\n  The rule to compare two n-tuples lexicographically can be generalized to tuples of different lengths. \nLet\n  <span style=\"white-space: nowrap;\">\n   (p\n   <sub>\n    1\n   </sub>\n   , p\n   <sub>\n    2\n   </sub>\n   , ... , p\n   <sub>\n    m\n   </sub>\n   )\n  </span>\n  and\n  <span style=\"white-space: nowrap;\">\n   (q\n   <sub>\n    1\n   </sub>\n   , q\n   <sub>\n    2\n   </sub>\n   , ... , q\n   <sub>\n    n\n   </sub>\n   )\n  </span>\n  be two tuples where\n  <span style=\"white-space: nowrap;\">\n   m &lt; n.\n  </span>\n </p>\n <ul>\n  <li>\n   If there is a j in the range 1 through m such that\n   <span style=\"white-space: nowrap;\">\n    p\n    <sub>\n     j\n    </sub>\n    \u2260 q\n    <sub>\n     j\n    </sub>\n    ,\n   </span>\n   then let k be the smallest \nk such that\n   <span style=\"white-space: nowrap;\">\n    p\n    <sub>\n     k\n    </sub>\n    \u2260 q\n    <sub>\n     k\n    </sub>\n    .\n   </span>\n  </li>\n  <ul>\n   <li>\n    If p\n    <sub>\n     k\n    </sub>\n    &gt; q\n    <sub>\n     k\n    </sub>\n    , then (p\n    <sub>\n     1\n    </sub>\n    , p\n    <sub>\n     2\n    </sub>\n    , ... , p\n    <sub>\n     m\n    </sub>\n    )  &gt;  (q\n    <sub>\n     1\n    </sub>\n    , q\n    <sub>\n     2\n    </sub>\n    , ... , q\n    <sub>\n     n\n    </sub>\n    )\n   </li>\n   <li>\n    If p\n    <sub>\n     k\n    </sub>\n    &lt; q\n    <sub>\n     k\n    </sub>\n    , then (p\n    <sub>\n     1\n    </sub>\n    , p\n    <sub>\n     2\n    </sub>\n    , ... , p\n    <sub>\n     m\n    </sub>\n    )  &lt;  (q\n    <sub>\n     1\n    </sub>\n    , q\n    <sub>\n     2\n    </sub>\n    , ... , q\n    <sub>\n     n\n    </sub>\n    )\n   </li>\n  </ul>\n  <li>\n   If p\n   <sub>\n    j\n   </sub>\n   =  q\n   <sub>\n    j\n   </sub>\n   for every j in the range 1 through m, then\n   <span style=\"white-space: nowrap;\">\n    (p\n    <sub>\n     1\n    </sub>\n    , p\n    <sub>\n     2\n    </sub>\n    , ... , p\n    <sub>\n     m\n    </sub>\n    )  &lt;   (q\n    <sub>\n     1\n    </sub>\n    , q\n    <sub>\n     2\n    </sub>\n    , ... , q\n    <sub>\n     n\n    </sub>\n    )\n   </span>\n  </li>\n </ul>\n <p>\n  The definition above corresponds exactly to how words are ordered in a dictionary. If one word is a prefix of another word,\nthen the prefix comes first. For example, \"worth\" comes before \"worthwhile\" in the dictionary.\nOtherwise, the two words are ordered according to  the first letter where the two words differ.\n </p>\n</div>\n", "input_type": null, "question": "<div class=\"question\">\n <span class=\"part\">\n  (c)\n </span>\n <div class=\"text\">\n  <p>\n   Let r and n be two positive integers such that r \u2264 n. Define P\n   <sub>\n    r, n\n   </sub>\n   to be the \nset of all non-empty subsets of {1, 2, \u2026, n} with r or fewer elements. \nWrite an algorithm which on input (r, n, S), where S \u2208 P\n   <sub>\n    r, n\n   </sub>\n   ,\nreturns the next largest element of P\n   <sub>\n    r, n\n   </sub>\n   in lexicographic order.\n  </p>\n </div>\n</div>\n", "choices": [], "correct_choice_index": null, "answer": "1), Return( \"Last subset\" )\nReturn( {s1+1} )", "explanation": null, "images": {"instructions": "4.16.5-exercise-instructions_div.png", "question": "4.16.5.2-exercise-question.png", "choices": []}}